# -*- coding: utf-8 -*-
"""food app.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R-aRVh-Bb3Wyz0blbKSWzAECqPXr_huE

# DO NOT CREATE OR DELETE ANY CELLS
## DO NOT CREATE OR DELETE ANY CELLS
### DO NOT CREATE OR DELETE ANY CELLS
#### DO NOT CREATE OR DELETE ANY CELLS
DO NOT CREATE OR DELETE ANY CELLS

# RUN THE CELL BELOW BEFORE YOU BEGIN
"""

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL BEFORE YOU BEGIN

import unittest
from unittest.mock import patch

"""# RUN THE CELL ABOVE BEFORE YOU BEGIN

# First Semester Project
## Food Ordering Application
A food vendor has approached you build a simple app to help theirs users order food.
The vendor sells the following food items
* Pizza at 6500 Naira
* Burger at 3000 Naira
* Noodles at 1300 Naira

Write the code for each of these functions to accurately capture a users order and display a receipt to the user.

NOTE: Users can order multiple items in different quantities

## INSTRUCTIONS
* Only type in the areas where you see the comment **"#Your Code Here"**.
* Delete this line **"raise NotImplementedError()"** you will find it directly under the **"#Your code here"** comment.
* Rename the file to the email you used in registering for this course.
* Do not delete any cells or change what is written in them except for the cells that you are supposed to write on.
* This project is worth 30 Marks so take it seriously and adhere strictly to the instructions.
"""

#PLEASE DO NOT MODIFY THIS CELL

def display_menu():
    """
    Description: Prints the menu options for the food items available in the ordering app.
                 since the app only has 3 food items you can order we add a fourth option to exit
                 the menu when they are done ordering.
    """
    print("Menu:")
    print("1. Pizza - 6500")
    print("2. Burger - 3000")
    print("3. Noodles - 1300")
    print("4. Exit Menu")

def get_user_choice():
    """
    Description: Takes user input to get the number corresponding to the chosen food item from the menu.
                 Ensures the input is a valid choice between 1 and 4.

                 If the input is not an integer return the error
                 'Invalid input. Please enter a valid number.'

                 If the input is an integer but not between 1 and 4 return the error
                 'Invalid choice. Please enter a number between 1 and 4.'
    """
    # YOUR CODE HERE
    while True:
        try:
            choice = int(input("Enter your choice (1-4): "))
            if 1 <= choice <= 3:  # Return the choice for food items (1-3)
                return choice
            elif choice == 4:  # Return None for exiting (option 4)
                return None
            else:  # Invalid choice (not 1-4)
                print("Invalid choice. Please enter a number between 1 and 4.")
                continue
        except ValueError:  # Invalid input (not an integer)
            print("Invalid input. Please enter a valid number.")
            continue

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

class TestGetUserChoice(unittest.TestCase):
    @patch('builtins.input', side_effect=['2'])
    def test_valid_choice(self, mock_input):
        result = get_user_choice()
        self.assertEqual(result, 2)

    @patch('builtins.input', side_effect=['invalid', '3'])
    def test_invalid_then_valid_choice(self, mock_input):
        result = get_user_choice()
        self.assertEqual(result, 3)

    @patch('builtins.input', side_effect=['5', '4'])
    def test_invalid_then_exit_choice(self, mock_input):
        result = get_user_choice()
        self.assertIsNone(result)

tester = TestGetUserChoice()
tester.test_valid_choice()
tester.test_invalid_then_valid_choice()
tester.test_invalid_then_exit_choice()

def get_quantity():
    """
    Description: Takes user input to get the quantity of the selected food item.
                 and ensures the input is a positive integer.

                 If the input is not an integer return the error
                 'Invalid input. Please enter a valid number.'

                 If the input is a negative integer or zero return the error
                 'Quantity must be greater than 0.'
    """
    # YOUR CODE HERE
    while True:
        try:
            quantity = int(input("Enter the quantity: "))
            if quantity > 0:
                return quantity
            else:
                print("Quantity must be greater than 0.")
                continue
        except ValueError:
            print("Invalid input. Please enter a valid number.")
            continue

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

class TestGetQuantity(unittest.TestCase):
    @patch('builtins.input', side_effect=['3'])
    def test_valid_quantity(self, mock_input):
        result = get_quantity()
        self.assertEqual(result, 3)

    @patch('builtins.input', side_effect=['invalid', '5'])
    def test_invalid_then_valid_quantity(self, mock_input):
        result = get_quantity()
        self.assertEqual(result, 5)

    @patch('builtins.input', side_effect=['0', '-2', '4'])
    def test_invalid_then_valid_quantity_with_negative_input(self, mock_input):
        result = get_quantity()
        self.assertEqual(result, 4)

tester = TestGetQuantity()
tester.test_valid_quantity()
tester.test_invalid_then_valid_quantity()
tester.test_invalid_then_valid_quantity_with_negative_input()

def get_item_name(choice):
    """
    Description: Retrieves and returns the name of a food item
    based on the user's choice number from the menu.
    """
    # YOUR CODE HERE
    if choice == 1:
        return 'Pizza'
    elif choice == 2:
        return 'Burger'
    elif choice == 3:
        return 'Noodles'

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

assert get_item_name(1) == 'Pizza'
assert get_item_name(2) == 'Burger'
assert get_item_name(3) == 'Noodles'

def get_item_price(choice):
    """
    Description: Retrieves and returns the price of a food item based on
    the user's choice number from the menu.
    """
    # YOUR CODE HERE
    if choice == 1:
        return 6500
    elif choice == 2:
        return 3000
    elif choice == 3:
        return 1300

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

assert get_item_price(1) == 6500
assert get_item_price(2) == 3000
assert get_item_price(3) == 1300

def calculate_total_price(item_price, quantity):
    """
    Description: Calculates and returns the total price of a specific food item
    based on its price and the quantity ordered.
    """
    # YOUR CODE HERE
    return item_price * quantity

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

assert calculate_total_price(5, 2) == 10

def place_order():
    """
    Description: Manages the process of adding items to a shopping cart.
                 USES A DICTIONARY FOR THE CART.
                 Calls other functions to get user choices, quantities, and calculates total prices.

                 Your cart should look something like this assuming this user ordered 3 pizzas and 3 burgers.
                 {
                    'Pizza': {'quantity': 3, 'total_price': 19500},
                    'Burger': {'quantity': 3, 'total_price': 9000}
                 }
    """
    # YOUR CODE HERE
    cart = {}  # Initialize an empty dictionary for the cart

    while True:
        choice = get_user_choice()  # Get the user's menu choice (1-3 for items, None to exit)
        if choice is None:  # Exit condition
            break

        quantity = get_quantity()  # Get the quantity for the selected item
        item_name = get_item_name(choice)  # Get the name of the item based on the choice

        # Define item prices (in Naira)
        prices = {
            'Pizza': 6500,
            'Burger': 3000,
            'Noodles': 1300
        }

        # Calculate total price for this item (quantity * price)
        total_price = quantity * prices[item_name]

        # Update the cart
        if item_name in cart:
            # If item already exists, update quantity and total_price
            cart[item_name]['quantity'] += quantity
            cart[item_name]['total_price'] += total_price
        else:
            # If item is new, add it to the cart
            cart[item_name] = {'quantity': quantity, 'total_price': total_price}

    return cart

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

class TestPlaceOrder(unittest.TestCase):
    @patch('__main__.get_user_choice', side_effect=[1, 2, None])
    @patch('__main__.get_quantity', return_value=3)
    def test_place_order(self, mock_get_quantity, mock_get_user_choice):
        result = place_order()

        # Assertions based on the expected behavior of place_order
        expected_result = {'Pizza': {'quantity': 3, 'total_price': 19500},
                           'Burger': {'quantity': 3, 'total_price': 9000}}
        self.assertEqual(result, expected_result)

        # Check that get_user_choice was called three times
        self.assertEqual(mock_get_user_choice.call_count, 3)

        # Check that get_quantity was called twice (for the two items added)
        self.assertEqual(mock_get_quantity.call_count, 2)

tester = TestPlaceOrder()
tester.test_place_order()

def check_out(cart):
    """
    Description: Finalizes the order by displaying the contents of the shopping cart, including quantities and total prices.
                 Prints the total order price like a receipt.

                 The receipt would look like this if the cart is empty

                     Your cart is empty. No items to check out.


                 If the Cart is has items in it then the receipt should look exactly like this

                     Checking out...
                     Your order details:
                     Item 1: Quantity - 2, Total Price - 2000
                     Item 2: Quantity - 3, Total Price - 1500
                     Total Order Price: 3500
                     Thank you for ordering!
    """
    # YOUR CODE HERE
    if not cart:  # Check if the cart is empty
        print("Your cart is empty. No items to check out.")
    else:
        print("Checking out...")
        print("Your order details:")
        item_count = 1
        total_order_price = 0

        # Iterate through items in the cart
        for item_name, details in cart.items():
            quantity = details['quantity']
            total_price = details['total_price']
            print(f"Item {item_count}: Quantity - {quantity}, Total Price - {total_price}")
            total_order_price += total_price
            item_count += 1

        print(f"Total Order Price: {total_order_price}")
        print("Thank you for ordering!")

#PLEASE DO NOT MODIFY THIS CELL
#RUN THIS CELL TO TEST YOUR CODE.
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

class TestCheckOut(unittest.TestCase):
    @patch('builtins.print')
    def test_check_out_empty_cart(self, mock_print):
        cart = {}
        check_out(cart)
        mock_print.assert_called_with("Your cart is empty. No items to check out.")

    @patch('builtins.print')
    def test_check_out_non_empty_cart(self, mock_print):
        cart = {
            'Item 1': {'quantity': 2, 'total_price': 20},
            'Item 2': {'quantity': 3, 'total_price': 15}
        }
        check_out(cart)

        # Verify that the expected output was printed
        expected_output_1 = [
            "Checking out...",
            "Your order details:",
            "Item 1: Quantity - 2, Total Price - $20",
            "Item 2: Quantity - 3, Total Price - $15",
            "Total Order Price: $35",
            "Thank you for ordering!"
        ]

        # Second expected output (alternate formatting, for example)
        expected_output_2 = [
            "Checking out...",
            "Your order details:",
            "Item 1: Quantity - 2, Total Price - 20",
            "Item 2: Quantity - 3, Total Price - 15",
            "Total Order Price: 35",
            "Thank you for ordering!"
        ]

        # Convert expected outputs to lists of mock calls
        calls_1 = [unittest.mock.call(output) for output in expected_output_1]
        calls_2 = [unittest.mock.call(output) for output in expected_output_2]

        try:
            # Check first expected output
            mock_print.assert_has_calls(calls_1, any_order=False)
        except AssertionError:
            # If the first expected output fails, check the second one
            mock_print.assert_has_calls(calls_2, any_order=False)


tester = TestCheckOut()
tester.test_check_out_empty_cart()
tester.test_check_out_non_empty_cart()

#PLEASE DO NOT MODIFY THIS CELL
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

def food_ordering_app():
    """
    Description: The main function that initiates the food ordering application.
                 Calls place_order() to build the shopping cart and then calls check_out() to complete the order.

                 NOTE THAT IF ANY OF THE OTHER FUNCTIONS ARE NOT CORRECTLY WRITTEN THIS WILL FAIL
                 PLEASE DO NOT MODIFY THIS CELL
    """
    print("Welcome to the Food Ordering App!")
    cart = place_order()
    check_out(cart)

#PLEASE DO NOT MODIFY THIS CELL
#IF YOU DO NOT GET ANY ERRORS WHEN YOU RUN THIS CELL THEN YOUR CODE WORKS AS EXPECTED

class TestFoodOrderingApp(unittest.TestCase):
    @patch('builtins.print')
    @patch('__main__.place_order', return_value={'Item 1': {'quantity': 2, 'total_price': 20}})
    @patch('__main__.check_out')
    def test_food_ordering_app(self, mock_check_out, mock_place_order, mock_print):
        food_ordering_app()

        # Verify that the expected calls were made
        mock_print.assert_called_with("Welcome to the Food Ordering App!")
        mock_place_order.assert_called_once()
        mock_check_out.assert_called_once()

tester = TestFoodOrderingApp()
tester.test_food_ordering_app()